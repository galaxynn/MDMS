好的，遵命！我已经将您提供的这份非常出色的 SOP 文档进行了格式上的精细优化和调整，使其在视觉上更具层次感、重点更突出、阅读体验更佳。核心内容和专业建议都已完整保留。

---

# **最终版 3.0：Git & Alembic 高效协作工作流**
## **(两人团队版)**

### 核心原则 (The Golden Rules)

> 1.  **`main` 分支是神圣的**：永远是可部署、稳定、最新的。**禁止**任何人直接 `push` 代码到 `main` 分支。
> 2.  **所有工作都在分支上进行**：无论是新功能、Bug 修复还是实验，都必须创建新的分支。
> 3.  **PR 是唯一的合并通道**：所有代码变更必须通过 Pull Request (PR) 并经过**另一名成员审查 (Review)** 后才能合并。
> 4.  **数据库变更也是代码**：Alembic 生成的迁移脚本必须和模型代码**一同提交**，一同审查。

---

### **阶段一：一次性项目准备 (The Foundation)**

这部分主要由仓库所有者完成，组员配合。

#### 1. GitHub 仓库设置

*   **添加协作者 (Collaborator)**：在仓库 `Settings > Collaborators` 中邀请你的组员。
*   **设置分支保护规则 (Branch Protection)**：这是保证流程规范的核心！
    *   前往 `Settings > Branches`，为 `main` 分支添加规则。
    *   **勾选 ✅ `Require a pull request before merging`**
        *   这会强制禁止直接 `push` 到 `main`。
    *   **勾选 ✅ `Require approvals` 并设置为 `1`**
        *   这确保了 PR 必须由另一人批准后才能合并。

#### 2. 本地项目初始化

*   **创建 `.gitignore` 文件**：在项目根目录创建 `.gitignore` 文件，忽略不必要的文件。这是**第一步**，至关重要。
    ```gitignore
    # Python
    __pycache__/
    *.pyc
    *.pyo
    *.pyd

    # Virtual environment
    venv/
    env/

    # Environment variables
    .env
    .env.*

    # IDE files
    .vscode/
    .idea/
    ```
*   **克隆仓库**：
    ```bash
    git clone [repository_url]
    ```
*   **初始化 Alembic** (如果项目还未设置):
    ```bash
    # 假设你使用 FastAPI 或 Flask
    pip install alembic python-dotenv
    alembic init alembic
    ```
*   **关键：配置 Alembic 以使用环境变量**
    1.  **不要**在 `alembic.ini` 中硬编码 `sqlalchemy.url`。
    2.  在你的项目根目录创建 `.env` 文件 (它已被 `.gitignore` 忽略，不会被提交)，并添加你的本地数据库连接字符串：
        ```
        DATABASE_URL="postgresql+psycopg2://user:password@localhost/mydb"
        ```
    3.  修改 `alembic/env.py` 文件，让它能读取 `.env` 中的变量：
        ```python
        # 在 alembic/env.py 文件的顶部
        import os
        from dotenv import load_dotenv

        # 加载 .env 文件 (假设 .env 在 alembic 目录的上两级，即项目根目录)
        # 调整路径 ('../../.env') 以适应你的项目结构
        load_dotenv(os.path.join(os.path.dirname(__file__), "..", "..", ".env"))

        # ... 其他 import 和代码 ...

        # 找到 config = context.config

        # (新增) 从环境变量中获取 DATABASE_URL 并设置到 Alembic 配置中
        db_url = os.environ.get("DATABASE_URL")
        if db_url:
            config.set_main_option("sqlalchemy.url", db_url)

        # ... 后续代码 ...
        ```
    4.  在 `alembic/env.py` 中，设置 `target_metadata`，使其指向你 SQLAlchemy 模型的 `Base.metadata`。
    5.  将 `alembic.ini` (现在已不含敏感信息) 和 `alembic/` 目录提交到 Git。

---

### **阶段二：日常开发循环 (The Development Loop)**

这个流程对**团队中的每一个人**都适用，循环往复。

#### **第 1 步：开始新任务（同步主线）**

在开始任何新工作前，永远先确保你的本地 `main` 分支与远程保持同步。

```bash
# 1. 切换到 main 分支
git switch main

# 2. 拉取远程最新代码
git pull origin main

# 3. (关键！) 更新本地数据库到最新结构
alembic upgrade head
```
> **为什么需要 `alembic upgrade head`？**
> 因为其他队友合并到 `main` 的代码可能包含了新的数据库迁移，你需要先将自己的本地数据库更新到最新状态，再开始新工作。

#### **第 2 步：创建功能分支**

基于最新的 `main` 分支，创建一个命名清晰的分支。

```bash
# 格式: <类型>/<简短描述>，例如：
# feature/user-login
# fix/payment-bug
# chore/update-dependencies

git switch -c feature/user-login
```

#### **第 3 步：开发与提交 (集成 Alembic)**

在你的新分支上安心地编写代码。

*   **常规代码提交**：
    ```bash
    git add .
    git commit -m "feat: 实现用户注册API"
    ```

*   **当修改了数据库模型时 (例如：给 User 表增加 `age` 字段)**：
    1.  **修改 SQLAlchemy 模型代码** (例如在 `models.py` 中)。
    2.  **自动生成迁移脚本**：
        ```bash
        # 描述性消息会成为迁移脚本的文件名和注释
        alembic revision --autogenerate -m "add age column to user table"
        ```
        这会在 `alembic/versions/` 目录下生成一个新的 Python 文件。
    3.  **检查迁移脚本**：**务必**打开新生成的迁移文件，确认其中的 `upgrade()` 和 `downgrade()` 函数**都**符合你的预期。
    4.  **将模型代码和迁移脚本一起提交**：
        ```bash
        git add models.py alembic/versions/xxxx_add_age_column.py
        git commit -m "feat: 为用户模型添加age字段并生成迁移"
        ```
    5.  **在本地应用迁移，测试代码**：
        ```bash
        alembic upgrade head
        ```

*   **💡 优化建议：编写规范的 Commit Message**
    使用 [Conventional Commits](https://www.conventionalcommits.org/) 规范，让提交历史清晰易读。
    *   `feat:` (新功能)
    *   `fix:` (修复 Bug)
    *   `docs:` (文档变更)
    *   `style:` (代码格式，不影响代码逻辑)
    *   `refactor:` (重构)
    *   `test:` (增加或修改测试)
    *   `chore:` (构建过程或辅助工具的变动)

#### **第 4 步：保持分支更新（推荐 Rebase）**

如果你的分支开发时间较长，`main` 分支可能已经更新了很多。为了避免最后出现巨大的合并冲突，建议定期将 `main` 的更新同步到你的分支。

```bash
# 1. 获取远程 main 的最新变更
git fetch origin main

# 2. 使用 rebase 将你的提交“重放”在最新的 main 之上
git rebase origin/main
```
> **`rebase` vs `merge`**：`rebase` 会让你的分支历史保持一条直线，非常清晰。`merge` 会产生一个合并提交。对于功能分支，`rebase` 通常是更好的选择。
> 如果 `rebase` 过程中出现冲突，解决后使用 `git add .` 和 `git rebase --continue`。

#### **第 5 步：推送并创建 Pull Request (PR)**

当功能开发完成并通过本地测试后：

```bash
# --force-with-lease 是 rebase 后的安全强制推送方式
# 如果没有 rebase，直接 git push origin feature/user-login
git push --force-with-lease origin feature/user-login
```

*   在 GitHub 上创建 PR，将 `feature/user-login` 合并到 `main`。
*   填写清晰的标题和描述，并在右侧指定另一位成员为 **Reviewer**。

#### **第 6 步：代码审查 (Code Review)**

审查者会检查你的代码，包括：
*   代码逻辑和实现是否正确。
*   代码风格是否符合规范。
*   **Alembic 迁移脚本是否合理**：`upgrade()` 是否正确？**`downgrade()` 函数是否也被正确实现**，能否安全回滚？

审查者可能会提出修改建议。你只需在本地分支上继续修改、提交、然后再次 `push`，PR 会自动更新。

#### **第 7 步：合并 PR**

当 PR 被批准后：
*   点击 GitHub 上的 "Merge Pull Request" 按钮。
*   **💡 优化建议**：使用 **"Squash and merge"** 选项。它会将你分支上的所有提交合并成一个清晰的提交记录进入 `main` 分支，让 `main` 的历史非常整洁。
    *   在点击确认合并时，**请手动编辑合并提交的信息 (Commit Message)**，使其符合 Conventional Commits 规范。例如：
        `feat: 完成用户登录和注册全流程 (PR #12)`
*   合并后，点击 "Delete branch" 删除远程功能分支。

#### **第 8 步：清理本地**

合并完成后，清理你的本地环境。

```bash
# 1. 回到 main 分支
git switch main

# 2. 拉取刚刚合并的代码
git pull origin main

# 3. 删除已合并的本地分支
git branch -d feature/user-login
```

---

### **阶段三：处理特殊问题**

#### **问题一：常规代码冲突**

当你的 PR 与 `main` 冲突时，GitHub 会提示。
**解决方法**（由 PR 发起者在本地分支上操作）：

```bash
# 1. 确保 main 是最新的
git switch main
git pull origin main

# 2. 切换回你的分支
git switch feature/user-login

# 3. 将最新的 main 合并进来（或 rebase）
git merge main  # 或者 git rebase main

# 4. Git 会提示冲突。手动打开冲突文件，解决并删除 <<<< >>>> 标记。

# 5. 提交解决冲突的结果
git add .
git commit -m "fix: resolve merge conflict with main" # 如果是 merge
# 或者 git add . && git rebase --continue            # 如果是 rebase

# 6. 再次推送到远程
git push origin feature/user-login
```
PR 会自动更新，冲突标记消失。

#### **问题二：Alembic 迁移冲突 (Multiple Heads)**

这是使用 Alembic 协作时最常见的问题。
*   **场景**：你和队友都基于同一个 `main` 版本，各自创建了一个数据库迁移分支，然后队友的 PR 先合并了。
*   **原因**：现在数据库历史有了两个“分叉”的头，Alembic 不知道应该先应用哪个。
*   **解决方法**（由后合并的 PR 发起者解决）：

    1.  **将最新的 `main` 合并到你的分支**（如上文所述）。
    2.  此时，在 `alembic/versions` 目录下会同时存在你和队友的两个新迁移文件。
    3.  运行 `alembic heads`，你会看到两个 head 的版本号。
    4.  **手动修复分叉**：
        *   打开**你的**迁移文件（后创建的那个）。
        *   找到 `down_revision = 'xxxx'` 这一行，`xxxx` 是你们开始分支时的共同父版本。
        *   将 `xxxx` 修改为**你队友的**迁移文件的版本号。
        *   这样就手动将两个分叉的迁移连接成了一条直线。
    5.  **(关键！) 审查并解决逻辑冲突**：
        *   **必须**同时打开你队友的迁移文件（刚合并的）和你的迁移文件（当前的）。
        *   通读两个文件的 `upgrade()` 和 `downgrade()` 函数，确认它们在逻辑上是否兼容。
        *   **注意**：你的迁移文件是基于旧的 `main` 生成的，它“不知道”队友的变更。如果你们都修改了同一张表，你可能需要**手动编辑你的迁移文件**，删除 `autogenerate` 产生的多余操作（比如重复的 `op.create_table`），只保留你真正需要的变更（比如 `op.add_column`）。
    6.  **(推荐) 重新测试迁移**：
        *   在本地重置数据库（或至少回滚到分叉点），并从头运行所有迁移，确保这条新的、合并后的迁移路径没有问题。
        *   `alembic downgrade base && alembic upgrade head`
    7.  运行 `alembic check`，如果没有输出，说明修复成功。
    8.  提交你对迁移文件的修改，然后 `push`。

---

### **附录：有用的 Alembic 诊断命令**

当你不确定时，这几个命令能帮你理清思路：

-   `alembic history`：显示所有迁移版本及其关系（能清晰地看到分支）。
-   `alembic current`：显示当前数据库处于哪个迁移版本。
-   `alembic heads`：显示当前的“头”版本。正常情况应为 1 个，如果出现多个，说明你遇到了上述的“Multiple Heads”问题。

---

### **总结：两人协作的生命线**

1.  **沟通先行**：开始任务前，简单同步一下：“我开始做登录功能了”。
2.  **勤拉 `main`**：每天开始工作前，执行 `git switch main && git pull origin main && alembic upgrade head`。
3.  **PR 尽早、尽小**：一个 PR 只做一个功能，方便审查。
4.  **信任审查**：认真对待队友的审查意见，这是代码质量的保证。
5.  **遇到冲突不要慌**：冲突是协作的正常现象，按照流程解决即可。

这份优化的流程结合了 Git 的最佳实践和 Alembic 的具体操作，可以最大限度地保证你们的仓库整洁、代码稳定、协作顺畅。